PLAN.MD

Project Title: LMArena Custom Interface (Fly.io Hosted Web App with User CAPTCHA Fallback)

Objective: Develop a fully functional web application hosted on Fly.io. The application will provide a UI for users to interact with beta.lmarena.ai using custom system prompts and target model IDs. The backend will leverage a stealthy Puppeteer instance to automate LMArena, and will guide the user to manually resolve persistent Cloudflare CAPTCHAs on the official LMArena site as a fallback mechanism.

Core Technologies:

Backend: Node.js v18+, Express.js, puppeteer-extra, puppeteer-extra-plugin-stealth, dotenv, uuid.

Frontend: HTML5, CSS3, Vanilla JavaScript (ES6+).

Hosting & Deployment: Fly.io, Docker (with xvfb and Chrome dependencies).

External Services (Optional - User Provided/Trial):

Rotating Residential Proxy Provider (credentials via environment variables).

Phase 0: Local Project Structure & Initial Setup

Action (Terminal): Create project directory.

mkdir lmarena-fly-webapp-final && cd lmarena-fly-webapp-final


Action (Terminal): Initialize Node.js project.

npm init -y
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Action (Terminal): Install dependencies.

npm install express puppeteer-extra puppeteer-extra-plugin-stealth dotenv uuid 
npm install --save-dev nodemon
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Action (File System): Create the following directory and file structure:

lmarena-fly-webapp-final/
├── public/                 # Frontend static files
│   ├── index.html
│   ├── style.css
│   └── script.js
├── src/                    # Backend source files
│   ├── app.js              # Main Express server setup
│   ├── puppeteerManager.js # Manages Puppeteer, LMArena interaction
│   └── utils.js            # Helper functions (logging, UUID)
├── .env                    # Local environment variables (ignored by git)
├── Dockerfile              # For Fly.io deployment
├── fly.toml                # Generated by flyctl, then configured
├── .gitignore
└── nodemon.json            # Optional, for development
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Action (File: .gitignore):

node_modules/
.env
npm-debug.log
*.log
# Mac specific
.DS_Store
# Fly.io specific (if any local build artifacts)
fly.lock
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Gitignore
IGNORE_WHEN_COPYING_END

Action (File: .env): Create for local development.

PORT=3001
LMARENA_URL=https://beta.lmarena.ai/
NODE_ENV=development
PUPPETEER_HEADLESS=false # Set to 'new' or true for actual headless testing locally
# PROXY_SERVER_URL=http://user:pass@yourproxy.com:port # Optional
DEBUG_MODE=true # For verbose logging
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Dotenv
IGNORE_WHEN_COPYING_END

Action (File: nodemon.json): (Optional)

{
  "watch": ["src/", "public/"],
  "ext": "js,json,html,css",
  "ignore": ["node_modules/"],
  "exec": "node src/app.js"
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

Action (package.json): Add dev script.

"scripts": {
  "start": "node src/app.js",
  "dev": "nodemon"
},
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

Action (Fly.io): Ensure flyctl is installed and you are logged in (fly auth login).

Phase 1: Backend - Utilities and Basic Server Structure

File: src/utils.js

Action: Implement helper functions.

const { v4: uuidv4 } = require('uuid');

const LOG_LEVELS = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
const CURRENT_LOG_LEVEL = process.env.DEBUG_MODE === 'true' ? LOG_LEVELS.DEBUG : LOG_LEVELS.INFO;

function log(level, message, ...args) {
    if (LOG_LEVELS[level.toUpperCase()] >= CURRENT_LOG_LEVEL) {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] [${level.toUpperCase()}]`, message, ...args);
    }
}

function generateUUID() {
    return uuidv4();
}

module.exports = { log, generateUUID };
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

File: src/app.js (Initial Setup)

Action: Set up Express server, static file serving, and basic routes.

require('dotenv').config();
const express = require('express');
const path = require('path');
const { log, generateUUID } = require('./utils');
const puppeteerManager = require('./puppeteerManager');

const app = express();
const PORT = process.env.PORT || 8080; // Fly.io provides PORT env var

app.use(express.json());
app.use(express.static(path.join(__dirname, '..', 'public')));

// Map to store resolvers for requests waiting for user CAPTCHA retry
const waitingForRetryResolvers = new Map(); 

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '..', 'public', 'index.html'));
});

// Main chat endpoint
app.post('/api/chat', async (req, res) => {
    const { 
        userPrompt, systemPrompt, targetModelA, targetModelB, 
        clientConversationId: existingClientConversationId, 
        clientMessagesHistory = [] // Ensure it defaults to empty array
    } = req.body;
    
    const requestId = generateUUID(); // Unique ID for this specific request cycle
    log('INFO', `Request ${requestId}: Received /api/chat`, { userPrompt: userPrompt ? userPrompt.substring(0,30)+'...' : 'N/A' });

    res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*', // Adjust for production if needed
    });

    const sseSend = (data) => {
        if (!res.writableEnded) {
            res.write(`data: ${JSON.stringify(data)}\n\n`);
        }
    };

    try {
        const pageInstance = await puppeteerManager.launchOrGetPage();
        if (!pageInstance) {
            throw new Error("Failed to launch or get Puppeteer page.");
        }
        
        // Function for interactWithLMArena to call when it needs to pause for user retry
        const waitForUserRetrySignal = () => {
            return new Promise((resolve) => {
                waitingForRetryResolvers.set(requestId, resolve);
                log('DEBUG', `Request ${requestId}: Paused, waiting for user retry signal.`);
            });
        };

        await puppeteerManager.interactWithLMArena(
            pageInstance,
            { 
                userPrompt, systemPrompt, targetModelA, targetModelB, 
                clientConversationId: existingClientConversationId || generateUUID(), // Generate new if not provided
                clientMessagesHistory,
                requestId // Pass requestId for logging/tracking
            },
            sseSend,
            waitForUserRetrySignal // Pass the function to pause execution
        );

    } catch (error) {
        log('ERROR', `Request ${requestId}: Error in /api/chat handler:`, error.message);
        sseSend({ type: 'ERROR', message: `Server error: ${error.message}` });
    } finally {
        if (!res.writableEnded) {
            log('INFO', `Request ${requestId}: Ending SSE stream for /api/chat.`);
            res.end();
        }
        // Cleanup resolver if it exists and wasn't used
        if (waitingForRetryResolvers.has(requestId)) {
            waitingForRetryResolvers.delete(requestId);
        }
    }
});

// Endpoint for frontend to signal a retry after user solves CAPTCHA on main site
app.post('/api/trigger-retry', (req, res) => {
    const { requestId } = req.body; // Frontend needs to send back the requestId
    log('INFO', `Request ${requestId}: Received /api/trigger-retry`);

    if (waitingForRetryResolvers.has(requestId)) {
        const resolve = waitingForRetryResolvers.get(requestId);
        resolve({ userRetrying: true }); // Signal the waiting Promise to continue
        waitingForRetryResolvers.delete(requestId);
        res.json({ status: 'OK', message: 'Retry signal sent to backend task.' });
    } else {
        log('WARN', `Request ${requestId}: No active action waiting for retry.`);
        res.status(404).json({ error: 'No active action waiting for retry, or request ID mismatched.' });
    }
});

app.listen(PORT, () => {
    log('INFO', `Server listening on port ${PORT}`);
    puppeteerManager.initialize(); // Initialize browser if not already done
});

process.on('SIGINT', async () => { 
    log('INFO', 'SIGINT received, shutting down...');
    await puppeteerManager.closeBrowser(); 
    process.exit(0); 
});
process.on('SIGTERM', async () => { 
    log('INFO', 'SIGTERM received, shutting down...');
    await puppeteerManager.closeBrowser(); 
    process.exit(0); 
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Phase 2: Backend - Puppeteer Manager & LMArena Interaction (src/puppeteerManager.js)

File: src/puppeteerManager.js

Action: Implement Puppeteer instance management and the core LMArena interaction logic.

const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const { log, generateUUID } = require('./utils');

puppeteer.use(StealthPlugin());

let browserInstance = null;
// For a personal tool on Fly.io free tier, a single page might be safer than trying to pool
// if memory is very constrained. Multiple concurrent users are not expected.
let currentPageInstance = null; 

const LMARENA_URL = process.env.LMARENA_URL || 'https://beta.lmarena.ai/';
const PROMPT_TEXTAREA_SELECTOR = 'textarea[placeholder*="Ask anything"], textarea[placeholder*="Send a message"]'; // Adjust based on actual site
const SEND_BUTTON_SELECTOR = 'form button[type="submit"]'; // Adjust

async function initialize() {
    if (!browserInstance) {
        await launchOrGetPage(); // Launch browser on startup
    }
}

async function launchOrGetPage() {
    if (browserInstance && browserInstance.isConnected()) {
        if (currentPageInstance && !currentPageInstance.isClosed()) {
            try {
                // Navigate to blank page to clear state if reusing page
                await currentPageInstance.goto('about:blank', {waitUntil: 'networkidle2'});
                log('DEBUG', 'Reusing existing page, navigated to about:blank.');
            } catch (e) {
                log('WARN', 'Failed to navigate existing page to about:blank, creating new.', e.message);
                try { await currentPageInstance.close(); } catch (closeErr) { /* ignore */ }
                currentPageInstance = await browserInstance.newPage();
            }
        } else {
            currentPageInstance = await browserInstance.newPage();
            log('DEBUG', 'Created new page in existing browser.');
        }
    } else {
        log('INFO', 'Launching new browser instance...');
        const headlessMode = process.env.PUPPETEER_HEADLESS === 'true' ? 'new' : false;
        const launchOptions = {
            headless: headlessMode,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage', // Important for Docker/Fly.io
                '--disable-accelerated-2d-canvas',
                '--no-first-run',
                '--no-zygote',
                // '--single-process', // Only if very memory constrained, may break things
                '--disable-gpu' // Often recommended for headless server environments
            ]
        };
        if (process.env.PROXY_SERVER_URL) {
            launchOptions.args.push(`--proxy-server=${process.env.PROXY_SERVER_URL}`);
        }
        browserInstance = await puppeteer.launch(launchOptions);
        log('INFO', 'Browser instance launched.');
        browserInstance.on('disconnected', () => {
            log('WARN', 'Browser disconnected!');
            browserInstance = null;
            currentPageInstance = null;
        });
        currentPageInstance = await browserInstance.newPage();
        log('DEBUG', 'Created new page in new browser.');
    }

    await currentPageInstance.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'); // Example, keep updated
    await currentPageInstance.setViewport({ width: 1366, height: 768 }); // Common viewport

    // Inject scripts to sniff Turnstile parameters and Supabase JWT
    await currentPageInstance.evaluateOnNewDocument(() => {
        window.capturedTurnstileParams = {};
        const originalTurnstileRender = window.turnstile?.render;
        if (originalTurnstileRender) {
            window.turnstile = new Proxy(window.turnstile, {
                get(target, prop) {
                    if (prop === 'render') {
                        return function(element, options) {
                            window.capturedTurnstileParams = { sitekey: options.sitekey, action: options.action, cData: options.cData, chlPageData: options.chlPageData, callbackName: options.callback?.name };
                            return originalTurnstileRender.apply(target, [element, options]);
                        };
                    }
                    return target[prop];
                }
            });
        }
        // Supabase JWT (arena-auth-prod-v1 cookie)
        // This is harder to get directly into window on new document load,
        // best to retrieve it via page.cookies() later.
    });
    return currentPageInstance;
}

async function closePage() {
    if (currentPageInstance && !currentPageInstance.isClosed()) {
        try {
            await currentPageInstance.close();
            log('INFO', 'Current page closed.');
        } catch(e){ log('WARN', 'Error closing page', e.message); }
    }
    currentPageInstance = null;
}

async function closeBrowser() {
    if (browserInstance) {
        try {
            await browserInstance.close();
            log('INFO', 'Browser instance closed.');
        } catch(e){ log('WARN', 'Error closing browser', e.message); }
    }
    browserInstance = null;
    currentPageInstance = null;
}

async function interactWithLMArena(page, options, sseSend, waitForUserRetrySignal) {
    const { userPrompt, systemPrompt, targetModelA, targetModelB, clientConversationId, clientMessagesHistory, requestId } = options;
    let attempt = 0;
    const MAX_ATTEMPTS_AFTER_USER_RETRY = 2; // Allow 1 initial try, 1 after user retry

    while(attempt < MAX_ATTEMPTS_AFTER_USER_RETRY) {
        attempt++;
        log('INFO', `Request ${requestId}: LMArena interaction attempt #${attempt}`);
        sseSend({ type: 'STATUS', message: `Attempting interaction with LMArena (Attempt ${attempt})...` });

        try {
            await page.goto(LMARENA_URL, { waitUntil: 'networkidle2', timeout: 60000 });
            sseSend({ type: 'STATUS', message: 'Navigated to LMArena.' });

            // Retrieve Supabase JWT from cookies
            const cookies = await page.cookies(LMARENA_URL);
            const authCookie = cookies.find(cookie => cookie.name === 'arena-auth-prod-v1');
            const supabaseJWT = authCookie ? authCookie.value : null;
            if (!supabaseJWT) log('WARN', `Request ${requestId}: Supabase JWT (arena-auth-prod-v1) not found.`);
            
            // --- Request Interception Logic ---
            await page.setRequestInterception(true);
            let apiRequestProcessed = false;
            let turnstileTokenFromPage = null;

            const requestHandler = async (interceptedRequest) => {
                const url = interceptedRequest.url();
                if (url.startsWith('https://arena-api-stable.vercel.app/evaluation')) {
                    apiRequestProcessed = true; // Mark that we've intercepted the key request
                    log('DEBUG', `Request ${requestId}: Intercepting LMArena API call: ${url}`);
                    let originalPayload;
                    try { originalPayload = JSON.parse(interceptedRequest.postData() || '{}'); } 
                    catch (e) { originalPayload = {}; }

                    const modifiedPayload = { ...originalPayload };
                    
                    // Populate/modify fields for LMArena's API structure
                    modifiedPayload.id = clientConversationId; // This is the evaluationSessionId
                    modifiedPayload.modality = "chat";
                    modifiedPayload.mode = "side-by-side";

                    // Construct messages array
                    const messages = [...clientMessagesHistory]; 
                    if (systemPrompt && (messages.length === 0 || messages[0].role !== 'system')) {
                        messages.unshift({ role: 'system', content: systemPrompt, id: generateUUID() /* or as LMArena expects */ });
                    }
                    const currentUserMessageId = generateUUID();
                    messages.push({ 
                        role: 'user', content: userPrompt, id: currentUserMessageId, 
                        evaluationSessionId: clientConversationId, // LMArena includes this
                        status: 'pending' // LMArena includes this
                        // ... other fields LMArena needs for a user message
                    });
                    
                    const modelAInternalId = targetModelA; // Assuming user provides the direct ID LMArena uses
                    const modelBInternalId = targetModelB;
                    const assistantAMessageId = generateUUID();
                    const assistantBMessageId = generateUUID();

                    messages.push({ role: 'assistant', content: "", id: assistantAMessageId, modelId: modelAInternalId, evaluationSessionId: clientConversationId, status: 'pending' });
                    messages.push({ role: 'assistant', content: "", id: assistantBMessageId, modelId: modelBInternalId, evaluationSessionId: clientConversationId, status: 'pending' });
                    
                    modifiedPayload.messages = messages;
                    modifiedPayload.modelAId = modelAInternalId;
                    modifiedPayload.modelAMessageId = assistantAMessageId;
                    modifiedPayload.modelBId = modelBInternalId;
                    modifiedPayload.modelBMessageId = assistantBMessageId;
                    modifiedPayload.userMessageId = currentUserMessageId;

                    // Get Turnstile token (page's own attempt, or after user solved on main site)
                    turnstileTokenFromPage = originalPayload.turnstileToken || interceptedRequest.headers()['cf-turnstile-response'];
                    if (turnstileTokenFromPage) {
                        modifiedPayload.turnstileToken = turnstileTokenFromPage;
                        log('DEBUG', `Request ${requestId}: Using page-provided Turnstile token.`);
                    } else {
                        log('WARN', `Request ${requestId}: No Turnstile token found in page's request to LMArena API.`);
                        // This situation might lead to the API call being blocked, triggering CAPTCHA fallback.
                    }
                    
                    const modifiedHeaders = { ...interceptedRequest.headers(), 'content-type': 'application/json' };
                    if (supabaseJWT) modifiedHeaders['supabase-jwt'] = supabaseJWT;
                    
                    log('DEBUG', `Request ${requestId}: Continuing LMArena API request with modified payload and headers.`);
                    interceptedRequest.continue({
                        method: 'POST',
                        postData: JSON.stringify(modifiedPayload),
                        headers: modifiedHeaders
                    });
                } else {
                    interceptedRequest.continue();
                }
            };
            page.on('request', requestHandler);

            // --- Response Streaming Logic ---
            const responseHandler = async (response) => {
                const url = response.request().url();
                if (url.startsWith('https://arena-api-stable.vercel.app/evaluation') && response.headers()['content-type']?.includes('text/event-stream')) {
                    log('DEBUG', `Request ${requestId}: SSE stream opened from LMArena API.`);
                    sseSend({ type: 'STATUS', message: 'Connected to LMArena stream. Models are responding...' });
                    try {
                        const streamText = await response.text(); // This will wait for the entire stream to finish
                        const chunks = streamText.split('\n\n').filter(Boolean);
                        for (const chunk of chunks) {
                            if (chunk.startsWith('data: ')) {
                                const jsonData = JSON.parse(chunk.substring(5).trim());
                                // Parse jsonData.a0, jsonData.b0, jsonData.ae, jsonData.be etc.
                                // And send structured { type: 'MODEL_CHUNK', modelKey: 'A'/'B', content: ..., finishReason: ... }
                                // Example:
                                if (jsonData.a0 !== undefined) sseSend({ type: 'MODEL_CHUNK', modelKey: 'A', content: jsonData.a0 });
                                if (jsonData.b0 !== undefined) sseSend({ type: 'MODEL_CHUNK', modelKey: 'B', content: jsonData.b0 });
                                if (jsonData.ae?.finishReason) sseSend({ type: 'MODEL_CHUNK', modelKey: 'A', finishReason: jsonData.ae.finishReason });
                                if (jsonData.be?.finishReason) sseSend({ type: 'MODEL_CHUNK', modelKey: 'B', finishReason: jsonData.be.finishReason });
                            }
                        }
                        log('INFO', `Request ${requestId}: SSE stream from LMArena API finished.`);
                        sseSend({ type: 'STREAM_END' });
                    } catch (streamError) {
                        log('ERROR', `Request ${requestId}: Error reading LMArena SSE stream:`, streamError);
                        sseSend({ type: 'ERROR', message: 'Error processing LMArena response stream.' });
                    }
                    // Make sure to end the client SSE stream if it hasn't been
                    if (typeof streamEmitter !== 'function' && streamEmitter.end && !streamEmitter.writableEnded) { // if streamEmitter is res
                        streamEmitter.end();
                    }
                } else if (url.startsWith('https://arena-api-stable.vercel.app/evaluation') && (response.status() === 401 || response.status() === 403)) {
                    log('WARN', `Request ${requestId}: LMArena API returned ${response.status()}. Potential CAPTCHA block.`);
                    // This will be caught by the CAPTCHA detection logic later if it's a full block
                    // If this response ends the interaction, the CAPTCHA detection needs to run.
                }
            };
            page.on('response', responseHandler);

            // --- Trigger Action ---
            log('DEBUG', `Request ${requestId}: Typing prompt: "${userPrompt.substring(0,30)}..."`);
            await page.waitForSelector(PROMPT_TEXTAREA_SELECTOR, { timeout: 10000 });
            await page.type(PROMPT_TEXTAREA_SELECTOR, userPrompt, {delay: 50 + Math.random() * 50});
            
            await page.waitForSelector(SEND_BUTTON_SELECTOR, { timeout: 5000 });
            await page.click(SEND_BUTTON_SELECTOR);
            log('INFO', `Request ${requestId}: Prompt submitted to LMArena page.`);
            sseSend({ type: 'STATUS', message: 'Prompt submitted. Waiting for models...' });

            // Wait for API request to be processed by interceptor or a timeout
            await new Promise(resolve => {
                let checkInterval = setInterval(() => {
                    if (apiRequestProcessed) {
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 100);
                setTimeout(() => { // Timeout if main API call wasn't intercepted
                    clearInterval(checkInterval);
                    if (!apiRequestProcessed) log('WARN', `Request ${requestId}: Main LMArena API call not intercepted within timeout.`);
                    resolve(); 
                }, 15000); 
            });


            // --- CAPTCHA Detection & User Fallback ---
            await page.waitForTimeout(5000 + Math.random() * 2000); // Give time for challenge page or widget to load

            const isChallengePage = page.url().includes('challenges.cloudflare.com');
            const isInteractiveWidgetVisible = await page.evaluate(() => 
                !!document.querySelector('iframe[src*="challenges.cloudflare.com/turnstile/if"]') || 
                !!document.querySelector('iframe[title*="captcha"], iframe[title*="challenge"]') // Generic catch
            );
            // Add more sophisticated check: is the expected content *not* visible?

            if (isChallengePage || isInteractiveWidgetVisible) {
                log('WARN', `Request ${requestId}: CAPTCHA detected (Page: ${isChallengePage}, Widget: ${isInteractiveWidgetVisible}). Attempt #${attempt}`);
                if (attempt < MAX_ATTEMPTS_AFTER_USER_RETRY -1) { // Only trigger user intervention on the first 'real' attempt
                   sseSend({ type: 'USER_ACTION_REQUIRED', message: `LMArena requires a security check. Please open ${LMARENA_URL} in a new browser tab, solve any CAPTCHAs there to ensure the site loads, then click 'Retry Action' in this app.`, requestId });
                   await waitForUserRetrySignal(); // This pauses until /api/trigger-retry is called
                   // After user retries, the loop will continue for the next attempt
                   page.off('request', requestHandler); // Important to remove old listeners
                   page.off('response', responseHandler);
                   await page.setRequestInterception(false);
                   continue; // Restart the while loop for a fresh attempt
                } else {
                    log('ERROR', `Request ${requestId}: CAPTCHA persisted after user retry. Aborting.`);
                    sseSend({ type: 'ERROR', message: 'CAPTCHA challenge persisted after retry. Please try a new session.' });
                    break; // Exit while loop
                }
            } else {
                log('INFO', `Request ${requestId}: No obvious CAPTCHA detected after action. Assuming API call will proceed or stream will start.`);
                // If no CAPTCHA, assume stream will provide data or an error.
                // Wait for stream to complete or a different error to occur.
                // The SSE response handler should eventually call sseSend({ type: 'STREAM_END' })
                // or an error handler should end the stream.
                // Add a general timeout here for the entire interaction for this attempt.
                await new Promise(resolve => setTimeout(resolve, 180000)); // 3 min timeout for models to respond
                log('INFO', `Request ${requestId}: Interaction attempt ${attempt} finished or timed out.`);
                break; // Assume success or stream handled it, exit while loop
            }

        } catch (error) {
            log('ERROR', `Request ${requestId}: Error during LMArena interaction (Attempt ${attempt}):`, error.message);
            if (attempt < MAX_ATTEMPTS_AFTER_USER_RETRY -1 && error.message.toLowerCase().includes('timeout')) { // Example: if timeout, maybe it was a challenge page
                sseSend({ type: 'USER_ACTION_REQUIRED', message: `Interaction timed out (Attempt ${attempt}). This might be a CAPTCHA. Please try solving on ${LMARENA_URL} and click 'Retry Action'.`, requestId });
                await waitForUserRetrySignal();
                page.off('request', requestHandler); 
                page.off('response', responseHandler);
                await page.setRequestInterception(false);
                continue; // Restart while loop
            }
            sseSend({ type: 'ERROR', message: `Interaction failed: ${error.message}` });
            break; // Exit while loop on other errors
        } finally {
            // Ensure listeners are removed if loop breaks or continues
            page.off('request', requestHandler);
            page.off('response', responseHandler);
            if (await page.isBound()) { // Check if page object is still valid
               await page.setRequestInterception(false).catch(e => log('DEBUG',`Error disabling interception: ${e.message}`));
            }
        }
    } // End while loop

    // End the SSE stream from the server side if not already ended
    if (typeof sseSend !== 'function' && sseSend.end && !sseSend.writableEnded) { // if sseSend is 'res'
         sseSend.end();
    } else if (typeof sseSend === 'function' && options.streamEmitter && options.streamEmitter.end && !options.streamEmitter.writableEnded) {
         options.streamEmitter.end(); // If a custom emitter was passed
    }
     log('INFO', `Request ${requestId}: interactWithLMArena finished.`);
}

module.exports = { initialize, launchOrGetPage, closePage, closeBrowser, interactWithLMArena };
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Phase 3: Frontend UI & Logic (public/)

File: public/index.html

Action:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LMArena Custom Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>LMArena Custom Interface</h1>
        
        <div class="settings">
            <label for="systemPrompt">System Prompt:</label>
            <textarea id="systemPrompt" rows="3">You are a helpful AI assistant.</textarea>
            
            <label for="modelAId">Target Model A ID:</label>
            <input type="text" id="modelAId" placeholder="e.g., lmsys/vicuna-7b-v1.5">
            
            <label for="modelBId">Target Model B ID (Optional for Battle):</label>
            <input type="text" id="modelBId" placeholder="e.g., lmsys/fastchat-t5-3b-v1.0">
        </div>

        <div class="chat-area">
            <div id="messageHistory" class="message-history"></div>
            <textarea id="userPrompt" placeholder="Type your prompt here..."></textarea>
            <button id="sendButton">Send</button>
            <button id="newConversationButton">New Conversation</button>
            <button id="retryActionButton" style="display: none;">Retry Action</button>
        </div>

        <div id="statusArea" class="status-area"></div>

        <div class="responses">
            <div class="response-column">
                <h2>Model A Response:</h2>
                <div id="modelAResponse" class="response-box"></div>
            </div>
            <div class="response-column">
                <h2>Model B Response:</h2>
                <div id="modelBResponse" class="response-box"></div>
            </div>
        </div>
    </div>
    <script src="script.js"></script>
</body>
</html>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Html
IGNORE_WHEN_COPYING_END

File: public/style.css

Action: Add basic styling for a pleasant chat interface.

body { font-family: sans-serif; margin: 0; background-color: #f4f4f4; display: flex; justify-content: center; padding-top: 20px; }
.container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 90%; max-width: 1000px; }
.settings label, .chat-area label { display: block; margin-top: 10px; margin-bottom: 5px; }
textarea, input[type="text"] { width: calc(100% - 20px); padding: 8px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
textarea#userPrompt { height: 80px; }
button { padding: 10px 15px; margin-right: 10px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
button:hover { background-color: #0056b3; }
#retryActionButton { background-color: #ffc107; color: black; }
.status-area { margin-top: 15px; padding: 10px; background-color: #e9ecef; border-radius: 4px; min-height: 20px; }
.responses { display: flex; justify-content: space-between; margin-top: 20px; }
.response-column { width: 48%; }
.response-box { border: 1px solid #eee; padding: 10px; min-height: 150px; background-color: #f9f9f9; white-space: pre-wrap; overflow-y: auto; max-height: 400px; border-radius: 4px; }
.message-history { border: 1px solid #eee; padding: 10px; min-height: 100px; background-color: #fdfdfd; white-space: pre-wrap; overflow-y: auto; max-height: 300px; margin-bottom: 10px; border-radius: 4px;}
.user-message { text-align: right; margin-bottom: 5px; }
.user-message span { background-color: #007bff; color: white; padding: 8px 12px; border-radius: 15px 15px 0 15px; display: inline-block; }
.assistant-message { text-align: left; margin-bottom: 5px; }
.assistant-message span { background-color: #e9ecef; color: #333; padding: 8px 12px; border-radius: 15px 15px 15px 0; display: inline-block; }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Css
IGNORE_WHEN_COPYING_END

File: public/script.js

Action: Implement frontend logic for API calls, SSE handling, and CAPTCHA fallback UI.

document.addEventListener('DOMContentLoaded', () => {
    const systemPromptEl = document.getElementById('systemPrompt');
    const modelAIdEl = document.getElementById('modelAId');
    const modelBIdEl = document.getElementById('modelBId');
    const userPromptEl = document.getElementById('userPrompt');
    const sendButton = document.getElementById('sendButton');
    const newConversationButton = document.getElementById('newConversationButton');
    const retryActionButton = document.getElementById('retryActionButton');
    const statusAreaEl = document.getElementById('statusArea');
    const modelAResponseEl = document.getElementById('modelAResponse');
    const modelBResponseEl = document.getElementById('modelBResponse');
    const messageHistoryEl = document.getElementById('messageHistory');

    let clientConversationId = null;
    let clientMessagesHistory = []; // Array of {role, content}
    let currentRequestIdForRetry = null; // Store requestId for retry functionality
    let eventSource = null;

    function generateClientUUID() { // Simple UUID for client-side message IDs
        return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }

    function displayMessageInHistory(role, content) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add(role === 'user' ? 'user-message' : 'assistant-message');
        const span = document.createElement('span');
        span.textContent = content;
        messageDiv.appendChild(span);
        messageHistoryEl.appendChild(messageDiv);
        messageHistoryEl.scrollTop = messageHistoryEl.scrollHeight;
    }

    newConversationButton.addEventListener('click', () => {
        clientConversationId = null; // Backend will generate new one if it receives null
        clientMessagesHistory = [];
        modelAResponseEl.textContent = '';
        modelBResponseEl.textContent = '';
        messageHistoryEl.innerHTML = '';
        statusAreaEl.textContent = 'New conversation started.';
        retryActionButton.style.display = 'none';
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        console.log("New conversation initiated.");
    });

    sendButton.addEventListener('click', async () => {
        const userPrompt = userPromptEl.value.trim();
        if (!userPrompt) {
            statusAreaEl.textContent = 'User prompt cannot be empty.';
            return;
        }

        sendButton.disabled = true;
        retryActionButton.style.display = 'none';
        modelAResponseEl.textContent = ''; // Clear previous stream
        modelBResponseEl.textContent = ''; // Clear previous stream

        displayMessageInHistory('user', userPrompt);
        clientMessagesHistory.push({ role: 'user', content: userPrompt, id: generateClientUUID() /* Add client-side ID if needed */ });
        userPromptEl.value = ''; // Clear input

        const payload = {
            userPrompt,
            systemPrompt: systemPromptEl.value.trim(),
            targetModelA: modelAIdEl.value.trim(),
            targetModelB: modelBIdEl.value.trim(),
            clientConversationId: clientConversationId, // Send current or null for new
            clientMessagesHistory: clientMessagesHistory.slice(0, -1) // Send history *before* current user prompt
        };

        statusAreaEl.textContent = 'Sending request to server...';

        if (eventSource) {
            eventSource.close(); // Close any existing connection
        }
        
        // We use fetch for POST, and backend uses res.write for SSE on that same connection
        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errData = await response.json().catch(() => ({ message: `HTTP error ${response.status}`}));
                throw new Error(errData.message || `Server error: ${response.status}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let partialModelAResponse = "";
            let partialModelBResponse = "";

            while (true) {
                const { value, done } = await reader.read();
                if (done) {
                    statusAreaEl.textContent = 'Stream finished.';
                    clientMessagesHistory.push({ role: 'assistant', model: 'A', content: partialModelAResponse });
                    clientMessagesHistory.push({ role: 'assistant', model: 'B', content: partialModelBResponse });
                    break;
                }
                
                const chunk = decoder.decode(value, { stream: true });
                // SSE messages are data: JSON\n\n
                const messages = chunk.split('\n\n');
                for (const message of messages) {
                    if (message.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(message.substring(5).trim());
                            // console.log('SSE Received:', data);

                            if (data.type === 'STATUS') {
                                statusAreaEl.textContent = data.message;
                            } else if (data.type === 'MODEL_CHUNK') {
                                if (data.modelKey === 'A') {
                                    partialModelAResponse += data.content || "";
                                    modelAResponseEl.textContent = partialModelAResponse;
                                } else if (data.modelKey === 'B') {
                                    partialModelBResponse += data.content || "";
                                    modelBResponseEl.textContent = partialModelBResponse;
                                }
                                if (data.finishReason) {
                                    statusAreaEl.textContent = `Model ${data.modelKey} finished: ${data.finishReason}.`;
                                }
                            } else if (data.type === 'USER_ACTION_REQUIRED') {
                                statusAreaEl.textContent = data.message;
                                currentRequestIdForRetry = data.requestId; // Store for retry button
                                retryActionButton.style.display = 'block';
                                // Stream might pause or end here from backend side
                            } else if (data.type === 'ERROR') {
                                statusAreaEl.textContent = `Error: ${data.message}`;
                                if(eventSource) eventSource.close();
                                return; // Stop processing stream on error
                            } else if (data.type === 'STREAM_END') {
                                statusAreaEl.textContent = 'Models finished responding.';
                                // Finalize history based on accumulated partial responses
                                const finalMsgA = clientMessagesHistory.find(m => m.role === 'assistant' && m.model === 'A' && m.content === ""); // Find placeholder
                                if (finalMsgA) finalMsgA.content = partialModelAResponse; else if(partialModelAResponse) clientMessagesHistory.push({role: 'assistant', model: 'A', content: partialModelAResponse});
                                
                                const finalMsgB = clientMessagesHistory.find(m => m.role === 'assistant' && m.model === 'B' && m.content === "");
                                if (finalMsgB) finalMsgB.content = partialModelBResponse; else if(partialModelBResponse) clientMessagesHistory.push({role: 'assistant', model: 'B', content: partialModelBResponse});
                                
                                // No need to close reader here, 'done' will handle it
                            }
                            // Update clientConversationId if this was the first message of a new conversation
                            // Backend needs to send it in one of the early STATUS or first MODEL_CHUNK messages
                            if (data.conversationId && !clientConversationId) {
                                clientConversationId = data.conversationId;
                                console.log("Conversation ID set:", clientConversationId);
                            }

                        } catch (e) {
                            console.warn('Error parsing SSE data or non-JSON message:', message, e);
                        }
                    }
                }
            }
        } catch (error) {
            console.error("Error sending/streaming chat:", error);
            statusAreaEl.textContent = `Error: ${error.message}`;
        } finally {
            sendButton.disabled = false;
        }
    });

    retryActionButton.addEventListener('click', async () => {
        if (!currentRequestIdForRetry) {
            statusAreaEl.textContent = "No action to retry.";
            return;
        }
        statusAreaEl.textContent = 'Signaling backend to retry action...';
        retryActionButton.disabled = true;
        try {
            const response = await fetch('/api/trigger-retry', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ requestId: currentRequestIdForRetry })
            });
            const data = await response.json();
            if (response.ok) {
                statusAreaEl.textContent = data.message + " Waiting for LMArena... (The previous stream should resume or a new one start if retry is processed)";
                // The backend should ideally resume the original SSE connection or the frontend
                // might need to re-initiate the /api/chat call if that's how retry is designed.
                // For this plan, we assume the backend's original /api/chat handler continues.
            } else {
                statusAreaEl.textContent = `Retry signal failed: ${data.error}`;
            }
        } catch (error) {
            statusAreaEl.textContent = `Error sending retry signal: ${error.message}`;
        } finally {
            retryActionButton.style.display = 'none'; // Hide after attempt
            retryActionButton.disabled = false;
            currentRequestIdForRetry = null;
        }
    });
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Phase 5: Dockerfile and Fly.io Configuration

File: Dockerfile

Action: Create a robust Dockerfile.

# 1. Base Image - Node.js LTS
FROM node:18-slim

# 2. Install System Dependencies for Puppeteer & Chrome
# Ref: https://pptr.dev/troubleshooting#running-puppeteer-in-docker
# Ref: puppeteer-real-browser might need xvfb if running non-headlessly effectively
RUN apt-get update \
    && apt-get install -y \
    wget \
    gnupg \
    # Dependencies for Chrome
    ca-certificates \
    fonts-liberation \
    libappindicator3-1 \
    libasound2 \
    libatk-bridge2.0-0 \
    libatk1.0-0 \
    libc6 \
    libcairo2 \
    libcups2 \
    libdbus-1-3 \
    libexpat1 \
    libfontconfig1 \
    libgbm1 \
    libgcc1 \
    libglib2.0-0 \
    libgtk-3-0 \
    libnspr4 \
    libnss3 \
    libpango-1.0-0 \
    libpangocairo-1.0-0 \
    libstdc++6 \
    libx11-6 \
    libx11-xcb1 \
    libxcb1 \
    libxcomposite1 \
    libxcursor1 \
    libxdamage1 \
    libxext6 \
    libxfixes3 \
    libxi6 \
    libxrandr2 \
    libxrender1 \

  libxss1 \
    libxtst6 \
    lsb-release \
    xdg-utils \
    # Xvfb for non-headless modes if puppeteer-real-browser needs it
    xvfb \
    --no-install-recommends \
    && rm -rf /var/lib/apt/lists/*

# OPTIONAL: Install Google Chrome Stable (if not relying on Puppeteer's bundled Chromium)
# This gives a more "real" browser environment often.
RUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - \
    && sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google-chrome.list' \
    && apt-get update \
    && apt-get install -y google-chrome-stable --no-install-recommends \
    && rm -rf /var/lib/apt/lists/*

# 3. Set up app directory
WORKDIR /usr/src/app

# 4. Copy package files and install dependencies
COPY package*.json ./
# Using --omit=dev for smaller production image
RUN npm install --omit=dev --production 

# 5. Copy application source code
COPY . .

# 6. Environment variables for Puppeteer
# If using system-installed Chrome:
ENV PUPPETEER_EXECUTABLE_PATH=/usr/bin/google-chrome-stable
# Puppeteer will download its own Chromium if this is not set and it can't find one.
# To prevent download if system chrome is used, also set:
ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true

ENV NODE_ENV=production
ENV PORT=8080 
ENV PUPPETEER_HEADLESS="new" # Use 'new' for modern headless, or "true"

# 7. Expose port
EXPOSE 8080

# 8. Start command
# If Xvfb is needed and not auto-managed by puppeteer-real-browser with headless:false
# CMD [ "xvfb-run", "-a", "--server-args=-screen 0 1366x768x24", "node", "src/app.js" ]
# If headless: 'new' or true, Xvfb is not needed
CMD [ "node", "src/app.js" ]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Dockerfile
IGNORE_WHEN_COPYING_END

File: fly.toml (Generate with fly launch, then edit)

Action:

app = "your-lmarena-app-name-final" # Replace with unique name
primary_region = "iad" # Choose a region close to you or your users

[build]
  dockerfile = "Dockerfile"

[env]
  PORT = "8080" # Fly.io injects this, Express should listen on it
  NODE_ENV = "production"
  PUPPETEER_HEADLESS = "new" # Override .env for production
  # LMARENA_URL and LMARENA_TURNSTILE_SITEKEY can be here or in secrets
  LMARENA_URL = "https://beta.lmarena.ai/"
  DEBUG_MODE = "false" 

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true  # For free tier, stops when idle
  auto_start_machines = true
  min_machines_running = 0   # Can scale to 0 for free tier

[[vm]] # Machine configuration
  cpu_kind = "shared"
  cpus = 1
  memory_mb = 1024 # Recommended for Node + Puppeteer + Chrome. 512MB is minimum to try.
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Toml
IGNORE_WHEN_COPYING_END

Action (Fly.io Secrets - Optional for Proxies):

If using proxies: fly secrets set PROXY_SERVER_URL="your_proxy_url_with_creds"

Phase 6: Deployment, Testing, and Refinement

Action (Terminal): Deploy to Fly.io.

fly deploy
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Action (Browser): Access your deployed app at https://your-lmarena-app-name-final.fly.dev.

Action (Terminal & Browser): Test all functionalities:

Sending prompts with/without system prompt.

Targeting different (known valid) Model A/B IDs.

SSE streaming of responses.

"New Conversation" button.

Force a CAPTCHA scenario: Use a VPN or try from a "cold" IP to see if LMArena challenges the Fly.io app. Test the "USER_ACTION_REQUIRED" flow and the "Retry Action" button.

Action (Terminal): Monitor logs: fly logs -a your-lmarena-app-name-final

Action (Refinement):

Adjust Puppeteer selectors in src/puppeteerManager.js if LMArena's UI changes.

Tune memory_mb in fly.toml based on observed usage.

Improve CAPTCHA detection heuristics if needed.

Enhance frontend UI/UX for clarity during CAPTCHA fallback.

